---
title: "题目笔记"
date: 2025-12-12 13:50:46
updated: 2025-12-12 13:50:46
mathjax: true
tags: 
    - LeetCode
    - Job
categories: 实用技巧
comments: true
---
# LeetCode Hot 100


## 1. 两数之和1-251210

#哈希表

```python
class Solution:
	def twoSum(self, nums: List[int], target: int) -> List[int]:
		dic = {}
		for i in range(len(nums)):
			residual = target - nums[i]
		if nums[i] in dic.keys():
			return [i, dic[nums[i]]]
		if residual not in dic.keys():
			dic[residual] = i
```

对每个数 留下 索引（value） 以及 到 target 的差（index），之后遇到 target差 的数，直接读出索引就行

## 2. 字母异位词分组49-251210

#哈希表 #排序

### 思路一：哈希

```python
class Solution:

	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		map = {}
		for item in strs:
			v = self.str2value(item)
			if v in map.keys():
				map[v].append(item)
			else:
				map[v] = [item]
		return list(map.values())
	
	def str2value(self, stR:str) -> int :
		res = 0
		for char in stR:
			index = ord(char)-ord('a')
			res += 10**(index)
		return res*len(stR)
```

第一次的思路就是 把一个 str 得到一个顺序无关的哈希值。但是复杂度好像有点高。

更好的实现方式：使用了 `from collections import defaultdict` #内置函数

使用  defaultdict 是内置 dict 的子类，核心特性是，当访问不存在的键时，会自动创建这个键并赋值为 **指定默认值** 而不是抛出 KeyError。例如：初始化 `mp=collections.defaultdict(list)` 如果访问了不存在的键就会默认为空list （传入int就是默认0）

还有一个 dict 的索引不能是 list dict set，可以是int float tuple str bool None frozenset ，list 可以转为tuple

```python
class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		dic = collections.defaultdict(list)
		for s in strs:
			count = [0] * 26
			for c in s:
				count[ord(c)-ord('a')]+=1
			# 这一步的时间复杂度是 O(k)+1 ,k=26 tuple生成这个hash值需要 list长度的时间
			dic[tuple(count)].append(s)
		return list(dic.values())
```

这个方法时间复杂度是 O(n(k+s)) s是字符集的大小 26，每个 str 要 k 来遍历字符， s来生成 hash表的键。

### 思路二-排序\* 最优

对每个str排序，然后将排序的这个 字符串 当做字典的索引（哈希值）时间复杂度是 O(nklogk)

#内置函数
sorted 函数 输入字符串 返回一个按照 unicode 编码的 char list
''.join(list(char)) 把charlist 拼成一个串 注意这个join是 字符串的子函数

```python
class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		dic = collections.defaultdict(list)
		for s in strs:
			index = ''.join(sorted(s))
			dic[index].append(s)
		return list(dic.values())
```

## 3. 最长连续序列128-251210

#并查集 #set

这个题要求了时间复杂度为O(n) 所以不考虑排序的方法，首先用 set 对 nums 去重，然后找到 所有序列开头的数字 并计算 这个序列的长度，**由于每个数仅进入一次内层循环**，所以时间复杂度符合要求。

```python
class Solution:
	def longestConsecutive(self, nums: List[int]) -> int:
		res = 0
		nums_set = set(nums)
		for i in nums_set:
			if i-1 in nums_set:
				continue
			# 否则说明这个数是 一个序列的开头
			l = 1
			p = i+1
			while p in nums_set:
				l+=1
				p+=1
			res = max(res,l)
		return res
```

下面这个节省20ms的时间
```python
class Solution:
	def longestConsecutive(self, nums: List[int]) -> int:
		res = 0
		nums_set = set(nums)
		for i in nums_set:
			if i-1 in nums_set:
				continue
			# 否则说明这个数是 一个序列的开头
			p = i+1
			while p in nums_set:
				p+=1
			res = max(res,p-i)
		return res
```

这个算法的关键是找到起点 避免对一个数的重复遍历
list 转 set 还有 判断 in set 的操作 时间复杂度是 O(1), 如果是用 list 的 in 时间复杂度是 O(n)

## 4. 移动零283-251210

#双指针 #快慢指针

### 思路一 遇到零放后面

list ： remove是移除 第一个 value，pop是删掉指定index的item
顺序遍历，把0移到最后

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		"""
		Do not return anything, modify nums in-place instead.
		"""
		i=0
		last = len(nums)
		while i < last :
			if nums[i] == 0 :
				nums.pop(i)
				nums.append(0)
				last-=1
				i-=1
			i+=1
```

### 思路二 栈 遇到非零压入栈

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		stack_size=0
		for num in nums:
			if num :
				nums[stack_size] = num
				stack_size+=1
		nums[stack_size:len(nums)] = [0]*(len(nums)-stack_size)
```

这个方法在最坏的情况下（全是0） 要遍历两次数组

### 思路三 双指针\* 最优

依次把非零元素移动到 数组靠左边的空位置上。参考快速排序的想法，快拍要确定一个待分割的元素x作为中间点，然后小于等于x放到左边，大于x放到右边。

一个指向第一个0 另一个遇到第一个非零就和第一个0换位置，然后指向第一个0的后移一位（仍然是第一个0） （这个理解好像不太好）

换一个想法，两个指针，慢的说明 其左边 全部都是 保留顺序的非零（也就是指向待处理序列的第一个，只有交换了也就是处理好了，才移动），快的去找下一个需要被处理的非零数字。这样保留了原本的顺序。

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		slow=fast=0
		while fast < len(nums):
			if nums[fast]:
				nums[slow],nums[fast]=nums[fast],nums[slow]
				slow+=1
			fast+=1
```

## 5. 盛最多水的容器11-251210

#双指针

首先对于壁 i<j 有:  $S=min(height[i],height[j])*(j-i)$  .
每次移动 width 一定会减少1，那么只有 min h 变大才会得到更多的水，所以每次需要让短的板子移动。
为什么双指针合理呢？我觉得有的算法的做法就是通过数学思路，舍弃掉 暴搜 的大部分区域，对于这个而言，爆搜的空间有 $len^2/2,i<j$ , 然后通过证明可以省掉很多搜索空间。

![[Pasted image 20251211160109.png]]

得到代码如下：
```python
class Solution:
	def S(self,i,j,h):
		h = h[i] if h[i]<h[j] else h[j]
		return abs(i-j)*h
	  
	def maxArea(self, height: List[int]) -> int:
		ans=0
		i,j = 0,len(height)-1
		while i!=j :
			ans = max(self.S(i,j,height),ans)
			if height[i]<height[j] :
				i+=1
			else :
				j-=1
		return ans
```

另一种想法，移动一边一定导致宽度下降，那么如果min(h,h)没有变大，就不需要计算，直接跳过就可以，直到高的最小值变大：
```python
class Solution:
	def maxArea(self, height: List[int]) -> int:
		l, r = 0, len(height) - 1
		ans = 0
		while l < r:
		# w = r - l
		h = min(height[l], height[r])
		ans = max(ans, (r - l) * h)
		while height[l] <= h and l < r: l += 1
		while height[r] <= h and l < r: r -= 1
	return ans
```


通过节省搜索空间的想法，还可以进一步，通过记录高度的最大值，得到最大的S，然后直接return

```python
class Solution:
	def maxArea(self, height: List[int]) -> int:
		max_area = 0
		l, r = 0, len(height) - 1
		max_height = max(height)
		  
		while l < r:
			if max_height * (r - l) < max_area:
				return max_area
			cur_area = min(height[l], height[r]) * (r - l)
			if cur_area > max_area:
				max_area = cur_area
			if height[l] > height[r]:
				r -= 1
			else:
				l += 1
		return max_area
```

## 6. 三数之和15-251211

#双指针

最简单的想法 对于每个数 当做一个两数之和来做，但是由于两数之和的解法复杂度是 $O(n)$，这种做法的复杂度是 $O(n^2)$.

还有一种是用双指针，来找和为 0 的 也是最优的。

```python
class Solution:
	def threeSum(self, nums: List[int]) -> List[List[int]]:
		nums.sort()
		ans = []
		n = len(nums)
		for i in range(n - 2):
			x = nums[i]
			if i > 0 and x == nums[i - 1]: # 跳过重复数字
				continue
			if x > 0 or nums[-1]<0 : # 优化一
				break
			if x + nums[-2] + nums[-1] < 0: # 优化二
				continue
			j = i + 1
			k = n - 1
			while j < k:
				s = x + nums[j] + nums[k]
				if s > 0:
					k -= 1
				elif s < 0:
					j += 1
				else: # 三数之和为 0
					ans.append([x, nums[j], nums[k]])
					j += 1
					while j < k and nums[j] == nums[j - 1]: # 跳过重复数字
						j += 1
					k -= 1
					while k > j and nums[k] == nums[k + 1]: # 跳过重复数字
						k -= 1
		return ans
```

这个方法和 第一个复杂度都是$O(n^2)$ 但是双指针要快一些啊，是因为 枚举 + 哈希表法虽是 O (n²)，但哈希表的额外开销、随机内存访问导致常数项远大于双指针；1. 双指针法的「$O(n^2)$」是**真 $O(n^2)$**（外层 n 次，内层 n 次），且常数项极小；

## 7. 接雨水42-251211

#单调栈 #动态规划 #双指针

### 思路一：单调栈\*

最开始的思路是 遍历所有h 而不是index 有一个问题就是，如果相等的话之后来了更高的没办法记录宽度，所以尝试用index做一下

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		stack = []
		ans = 0
		for i,h in enumerate(height) :
			while stack and h > height[stack[-1]] :
				top = stack.pop()
				if not stack :
					break
				# 这个是重点部分 好好想一下
				ans += (min(height[stack[-1]],h)-height[top])*(i-stack[-1]-1)
			stack.append(i)
		return ans
```
这个部分我觉得最难的是 每次加多少面积，由于单调栈有单调递减的特征，所以栈顶元素一定是最小的，计算的思路就是 记录 每次pop 添加的水 是一排 就是接雨水 水平线往上的？

### 思路二：动态规划

每个位置 i 能接的水的数量 = min( i 左边的最大高度, i 右边的最大高度) - h\[i\] ,所以暴力搜索就是：
```python
class Solution:
	def trap(self, height: List[int]) -> int:
		ans = 0
		l = len(height)
		dp = [0] * l
		# 暴力
		for i in range(1,l-1) :
			dp[i] = max(min(max(height[0:i]),max(height[i+1:])) - height[i],0)
		return sum(dp)
```

在内循环中，在数组中找max操作复杂度为 $O(n)$ , 所以这个暴力搜索的复杂度为 $O(n^2)$ ，通过 动态规划的思路 先用两个list： $O(n)$ 来记录  index i 左边的最大和右边的最大height是多少。

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		l = len(height)
		ans = [0] * l
		# 左侧最大值 不包括
		leftMax = [0] * l
		# 右侧最大值 不包括
		rightMax = [0] * l
		maxh = 0
		maxr = 0
		# 这里也可以用动态规划的状态转移方程 会更快
		for i in range(l) :
			leftMax[i] = maxh
			maxh = maxh if maxh > height[i] else height[i]
			rightMax[l-1-i] = maxr
			maxr = maxr if maxr > height[l-1-i] else height[l-1-i]
		for i in range(1,l-1) :
			# ans[i] = max(min(max(height[0:i]),max(height[i+1:])) - height[i],0)
			ans[i] = max(min(leftMax[i],rightMax[i]) - height[i],0)
		return sum(ans)
```

### 思路三：双指针

本质上和动态规划类似，只是用双指针的方法可以把空间复杂度减到O1，时间复杂度还是 $O(n)$

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		ans = 0
		left, right = 0, len(height) - 1
		leftMax = rightMax = 0
		while left < right:
			leftMax = max(leftMax, height[left])
			rightMax = max(rightMax, height[right])
			if height[left] < height[right]:
				ans += leftMax - height[left]
				left += 1
			else:
				ans += rightMax - height[right]
				right -= 1
		return ans
```

## 8.  无重复字符的最长子串3-251212

#滑动窗口

这个比较简单，可以学习一下别人的代码思路

```python
class Solution:
	def lengthOfLongestSubstring(self, s: str) -> int:
		ans,i,l = 0,0,len(s)
		window = collections.deque()
		count = collections.defaultdict(int)
		while i < l :
			while i < l and count[s[i]] == 0 :
				window.append(s[i])
				count[s[i]] += 1
				i += 1
				ans = max(len(window),ans)
			while i < l and count[s[i]]!=0 :
				f = window.popleft()
				count[f] -= 1
		return ans
```