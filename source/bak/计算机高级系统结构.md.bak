---
title: "计算机高级系统结构"
date: 2024-12-26 23:55:27
updated: 2025-04-30 01:17:38
math: true
---

# 第一章 量化设计与分析基础

## 计算机分类类别

![[Pasted image 20241226140214.png]]
![[Pasted image 20241226140309.png]]
嵌入式作为一个系统的一部分，还应考虑其实时性

## 计算机系统结构定义和计算机的设计任务：指令集结构概念以及要素

![[Pasted image 20241226140503.png]]
![[Pasted image 20241226140708.png]]

![[Pasted image 20241226140521.png]]
![[Pasted image 20241226140547.png]]
![[Pasted image 20241226140600.png]]


## 实现的技术趋势：技术发展趋势

![[Pasted image 20241226140815.png]]

![[Pasted image 20241226140923.png]]
cache用的是sram 主存用的是dram
![[Pasted image 20241226140933.png]]
![[Pasted image 20241226140947.png]]
![[Pasted image 20241226141117.png]]


## 集成电路功耗的趋势：功耗的概念

![[Pasted image 20241226141154.png]]

![[Pasted image 20241226141328.png]]
![[Pasted image 20241226141355.png]]
![[Pasted image 20241226141407.png]]


## 可靠性：计算可靠性的方法

![[Pasted image 20241226141524.png]]
![[Pasted image 20241226141531.png]]
![[Pasted image 20241226141648.png]]
![[Pasted image 20241226141726.png]]

## 测量、报告和总结计算机性能：计算机主要性能指标

![[Pasted image 20241226141828.png]]
![[Pasted image 20241226141910.png]]

![[Pasted image 20241226141919.png]]
如果一个是RISC一个CISC这种MIPS的比较方法就不公平 （CPI可能不一样）
可以先算IPS每秒执行多少指令，然后再除1million（1后面6个0）
![[Pasted image 20241226142150.png]]
![[Pasted image 20241226142202.png]]

![[Pasted image 20241226142341.png]]
![[Pasted image 20241226142346.png]]

![[Pasted image 20241226142353.png]]

![[Pasted image 20241226142537.png]]
![[Pasted image 20241226142542.png]]

![[Pasted image 20241226142618.png]]

## 计算机设计的量化原则：Amdahl定律

![[Pasted image 20241226142636.png]]

![[Pasted image 20241226142647.png]]
![[Pasted image 20241226142655.png]]
![[Pasted image 20241226142702.png]]
![[Pasted image 20241226142713.png]]
![[Pasted image 20241226142720.png]]
![[Pasted image 20241226142730.png]]
![[Pasted image 20241226142741.png]]
![[Pasted image 20241226142752.png]]
![[Pasted image 20241226142810.png]]
![[Pasted image 20241226142824.png]]

## 陷阱

![[Pasted image 20241226142933.png]]
![[Pasted image 20241226142949.png]]
![[Pasted image 20241226143053.png]]
![[Pasted image 20241226143058.png]]

![[Pasted image 20241226143225.png]]

# 第二章 指令系统原理与实例

## 指令集系统结构的分类：指令集系统的不同结构

![[Pasted image 20241226144553.png]]
![[Pasted image 20241226144559.png]]
![[Pasted image 20241226144616.png]]

![[Pasted image 20241226144705.png]]
![[Pasted image 20241226144726.png]]
![[Pasted image 20241226144745.png]]
![[Pasted image 20241226144852.png]]


## 存储器寻址：大小端模式及地址对齐

![[Pasted image 20241226144916.png]]
![[Pasted image 20241226144958.png]]
![[Pasted image 20241226145009.png]]
![[Pasted image 20241226145049.png]]

![[Pasted image 20241226145102.png]]
![[Pasted image 20241226145112.png]]
![[Pasted image 20241226145157.png]]
![[Pasted image 20241226145215.png]]
##  MIPS系统结构：MIPS指令集结构

![[Pasted image 20241226145808.png]]
![[Pasted image 20241226145816.png]]
![[Pasted image 20241226145830.png]]
![[Pasted image 20241226145843.png]]
![[Pasted image 20241226145909.png]]
![[Pasted image 20241226145922.png]]

## 其他

![[Pasted image 20241226145440.png]]
![[Pasted image 20241226145509.png]]
![[Pasted image 20241226145535.png]]
![[Pasted image 20241226145550.png]]
所以跳转指令中imm 在sign后要<<2 因为表示的是指令个数，一个指令4字节
![[Pasted image 20241226145702.png]]
# 第三章 单周期MIPS处理器的设计

## add, sub, addi, subi, lw, sw, beq, j 每条指令在单周期处理器中的执行逻辑以及 上述指令的指令编码、代码、功能以及在单周期中的数据通路，条件分支指令的地址计算、单周期各功能部件的控制信号值判断

![[Pasted image 20241226150322.png]]
只有位运算 & j是0拓展 
![[Pasted image 20241226150359.png]]
![[Pasted image 20241226150508.png]]
![[Pasted image 20241226151838.png]]
![[Pasted image 20241226151850.png]]
![[Pasted image 20241226151917.png]]

## 中断和异常的处理时机

![[Pasted image 20241226152028.png]]
![[Pasted image 20241226152035.png]]
![[Pasted image 20241226152053.png]]
![[Pasted image 20241226152118.png]]
![[Pasted image 20241226152124.png]]
![[Pasted image 20241226152137.png]]
![[Pasted image 20241226152150.png]]

# 第四章 流水线技术及指令级并行

## 流水线的概念、分类

![[Pasted image 20241226152703.png]]
![[Pasted image 20241226152644.png]]
![[Pasted image 20241226152739.png]]

![[Pasted image 20241226152811.png]]
![[Pasted image 20241226152819.png]]
![[Pasted image 20241226152830.png]]
![[Pasted image 20241226152837.png]]
![[Pasted image 20241226152843.png]]
![[Pasted image 20241226152852.png]]
![[Pasted image 20241226152902.png]]
![[Pasted image 20241226152909.png]]
![[Pasted image 20241226152914.png]]
![[Pasted image 20241226152920.png]]
![[Pasted image 20241226152928.png]]



## 流水线的时空图及性能指标计算

![[Pasted image 20241226153028.png]]![[Pasted image 20241226153023.png]]
![[Pasted image 20241226153038.png]]
![[Pasted image 20241226153045.png]]
![[Pasted image 20241226153142.png]]
![[Pasted image 20241226153150.png]]
![[Pasted image 20241226153214.png]]
![[Pasted image 20241226153247.png]]
![[Pasted image 20241226153308.png]]

![[Pasted image 20241226153320.png]]![[Pasted image 20241226153324.png]]
![[Pasted image 20241226153330.png]]
![[Pasted image 20241226153336.png]]
![[Pasted image 20241226153341.png]]
![[Pasted image 20241226153401.png]]
![[Pasted image 20241226153412.png]]

![[Pasted image 20241226153515.png]]


![[Pasted image 20241226154009.png]]
![[Pasted image 20241226154025.png]]

## add, sub, addi, or, ori, lw, sw, beq每条指令在5级流水线的执行过程

## 结构冒险、数据冒险和控制冒险的判断，以及需要暂停的时钟周期数的判断（控制冒险的解决性能依赖于分支地址计算阶段和分支条件判断阶段）

![[Pasted image 20241226155023.png]]
### 结构冒险以及三个解决办法
![[Pasted image 20241226171805.png]]
![[Pasted image 20241226171813.png]]
![[Pasted image 20241226171826.png]]
![[Pasted image 20241226172002.png]]

### 数据冒险以及解决办法
数据冒险指的是 写后读 RAW
![[Pasted image 20241226172141.png]]
![[Pasted image 20241226172148.png]]
![[Pasted image 20241226172218.png]]
![[Pasted image 20241226172241.png]]
![[Pasted image 20241226172251.png]]

![[Pasted image 20241226173516.png]]
![[Pasted image 20241226173528.png]]
办法2:数据前推
![[Pasted image 20241226173621.png]]
注意是 从 流水线寄存器 中取出数据到操作数中
![[Pasted image 20241226174011.png]]
对于 lw 。。 op 。。 这种数据冒险，由于lw在 MEM阶段过后 结果才存在在流水线寄存器中
所以要对下面的在IF ID中进行stall 暂停流水线：保持PC寄存器和IF/ID寄存器不变
![[Pasted image 20241226174142.png]]
![[Pasted image 20241226174150.png]]
![[Pasted image 20241226174245.png]]


### 控制冒险以及解决办法

![[Pasted image 20241226172317.png]]
![[Pasted image 20241226172403.png]]
![[Pasted image 20241226172439.png]]
![[Pasted image 20241226172511.png]]
![[Pasted image 20241226172616.png]]
![[Pasted image 20241226172719.png]]
![[Pasted image 20241226172726.png]]
![[Pasted image 20241226172732.png]]
![[Pasted image 20241226172758.png]]
![[Pasted image 20241226172751.png]]
![[Pasted image 20241226172833.png]]
![[Pasted image 20241226172917.png]]
![[Pasted image 20241226172954.png]]

如果add在alu中 mem阶段过后 pc在得到正确的下一个指令地址
![[Pasted image 20241226174440.png]]
在ID及计算转移地址
![[Pasted image 20241226174506.png]]
![[Pasted image 20241226174829.png]]
如果分支预测错误就flush ID/EXE寄存器 ，即把转移指令的下一个指令转为NOP 空指令。
flush 
	指令编码变全0：流水线定义编码为全0的指令为nop指令，语义：什么工作都不做。 IF.Flush有效，则将该指令在打入IF/ID寄存器时变为nop指令。
	指令编码不变：将该指令的所有写信号全部关闭。

## 结构冒险、数据冒险和控制冒险的解决办法

stall理解为关闭要等待指令的写信号

结构冒险：
	1. 插入暂停周期，即让流水线在完成前一条指令对数据的存储器访问时，暂停取后一条指令（指令存储器）的操作
	2. 设置相互独立的指令存储器和数据存储器或设置相互独立的指令Cache和数据Cache
	3. 预取指令技术（在重叠操作中，当前一条指令在执行过程中就需要提前取出后面的指令进行相应处理，这种提前取出后继指令进行相应处理，称为先行（预取）。）

数据冒险：
	1. 写回WB操作提前半个周期
	2. 数据前推：如果发现与结下来的1、2条指令存在数据冒险。从流水线寄存器中拿出 数据到冲突的指令操作数。 由于要检测两个位置，每个ALU输入需要一个 四路复选。
		- 对于 lw 。。 op 。。 这种数据冒险，由于lw在 MEM阶段过后 结果才存在在流水线寄存器中
		所以要对下面的在IF ID中进行stall 暂停流水线：保持PC寄存器和IF/ID寄存器不变

控制冒险：
	1. 转移Stalls ，但会造成大的性能损失
	2. 改进分支预测技术 
		- 静态预测：例如总是预测分支不发生（即假设分支不发生，属于静态预测机制）（成功率在50%左右）。 
		- 动态预测： 转移预测缓存 1位或者2位 或者 转移目标缓存（把为转移的后继指令保存预测地址的转移预测Cache称为转移目标缓存或转移目标Cache。）
	3. 延迟转移、缩小延迟槽：延迟转移是指在转移指令后顺序执行一条无关的指令，然后再进行转移。缩小延迟槽是尽早计算出转移目标地址，例如EXE阶段的ADD移动到 ID阶段 

## 流水线中处理中断和异常的方法

![[Pasted image 20241226175556.png]]
![[Pasted image 20241226175605.png]]
![[Pasted image 20241226175611.png]]
处理完后PC是PC_origin+4
![[Pasted image 20241226175710.png]]

流水线处理机处理异常的方式：
![[Pasted image 20241226175837.png]]
![[Pasted image 20241226175855.png]]
！！EX/MEM被清除是周期结束之后清楚掉add的结果 在周期完成之后才进行异常的处理
![[Pasted image 20241226175904.png]]
![[Pasted image 20241226180024.png]]
![[Pasted image 20241226180037.png]]

### 精确非精确异常

![[Pasted image 20241226180817.png]]
![[Pasted image 20241226180846.png]]
![[Pasted image 20241226180911.png]]
同一个周期内多个阶段出现异常，先处理最早流入流水线的异常。
![[Pasted image 20241226180920.png]]

![[Pasted image 20241226181015.png]]
![[Pasted image 20241226181043.png]]


## 其他

打乱顺序可以提高并行程度，有静态调度（编译器）和动态调度（硬件实现）
![[Pasted image 20241226181305.png]]
![[Pasted image 20241226181312.png]]
写后写 读后写 和数据冒险（写后读）这几种不能调整顺序。
![[Pasted image 20241226181323.png]]

循环展开
![[Pasted image 20241226181437.png]]

还有一些利用了时空相似性提高cache命中的方法 例如 合并数组、合并独立循环、调整循环顺序等。

## 记分牌/Tomasulo动态调度算法！！！！！！！！！！！！！！

### 计分牌

四个阶段

1. IS（Issue）：顺序发射指令
	- （进入条件）在执行发射之前，检查 ： 1.结构冲冲突 即busy；    2. 写写冲突，检查 寄存器状态表 是不是有 写写冲突
	- （计分牌记录内容）
		- 把要使用的部件 Busy置为Yes 记录Op Fd Fj Fk Qj Qk Rj Rk记录
		- 在寄存器状态表中 要写的寄存器来源记为当前功能单元 

2. RO（Read Operand）：读操作数
	- （进入条件）Rj · Rk = 1 两个操作数必须都要同时准备好 解决了先写（还没准备好，要等准备好之后才能读）再读（数据冒险）
	- （计分牌记录内容）
		- R yes转为no 已经被读 Qj Qk转为0

3. EXE 执行

4. WB（WriteBack）：写回
	- （进入条件）检查要写的寄存器是不是其他已经准备好的内容 比如要写F0 但是有条指令要用F0 而且状态是yes 那么就不能写。 解决的是读写冲突
	- （计分牌内容）如果有Q在等待当前WB的部件，把Q去掉，F写进去，R置为Yes 然后把状态寄存器中的等待部件释放 释放BUSY


三张表：
1. 指令状态表 记录各个指令运行到哪个状态 
	- Instruction  IS   RO   EXE   WB
2. 计分板 记录各个部件的情况
	- 部件名 Busy Op(instruction) Fd Fj Fk Qj Qk Rj Rk    Q指的是要来源于哪个部件或者功能单元 R指的是是否准备好
3. 寄存器状态表 记录各个寄存器将要被谁 哪个部件（功能单元） 写入

### Tomasulo动态调度算法

数据传递主要是用CDB 公共数据总线

每个部件之前都有 保留站 reverse station

![[Pasted image 20241226212059.png]]
访存unit是单独的store buffer 和load buffer

三个阶段
1. IS（Issue）：顺序发射指令
	- 如果要进入的部件的 保留站 有位置 就把当前指令载入到保留站中，若其中的操作数在寄存器就绪就将其送入保留站，如果未就绪就在保留站中记录产生该操作数的保留站编号（操作数寄存器名换成了保留站名）。
	- 如果是访存操作且有空的缓冲就流出到缓冲。
	- 如果没有空的保留站和缓冲，即有结构相关，就不流出。
	- 如果IS时候源操作数在FPReg中有值 就直接填入进来（防止WAR）即数据冒险
	- 如果有操作数还没写完，就在Q中记录tag

2. EXE 执行： 如果保留站的操作数未计算出，就用保留站编号监视CDB（公共数据总线），一旦有结果就取到保留站中，当两个操作数就绪，进入执行阶段，执行指令操作。解决先写后读相关（RAW）。

3. WB（WriteBack）：功能部件完成计算后，将结果连同产生该结果的保留站号一起送到CDB上。根据流出时的记录，所有等待本保留站结果的保留站、存缓冲、目标寄存器将同时从CDB上获得所需数据。

三张表：

1. 指令状态表 记录各个指令运行到哪个状态 
	- Instruction  IS   EXE   WB
2. 计分板 记录各个保留站的情况
	- （保留站每一条的）标志tag Busy Op(instruction) Vj Vk  Qj Qk A 
	- V是操作数的数值，Q是在等待的保留站条目的tag 两个只有一个有效 Q=0 表示 操作数在V中或者不需要这个操作数，A存的是存储器地址
3. 寄存器状态表 记录各个寄存器将要被谁 哪个 tag（最新的）  写入 也可以包括寄存器的值

如果有写写冲突，因为 顺序issuse 在寄存器堆中都会记录正确的最新的数据来源

load在exe阶段可以计算出要访问的地址，然后再WB阶段才写回
# 第五章 存储系统

## 存储器的分类和主要特点

SRAM一般CACHE DRAM一般是MEM 因为D要刷新，重启之后数据都没有了。
![[Pasted image 20241226182450.png]]
![[Pasted image 20241226182541.png]]
![[Pasted image 20241226183212.png]]
![[Pasted image 20241226183218.png]]


![[Pasted image 20241226182636.png]]
![[Pasted image 20241226182644.png]]
![[Pasted image 20241226183149.png]]
## Cache的三种映像关系：全相联、直接映像、组相联

![[Pasted image 20241226183304.png]]
![[Pasted image 20241226183311.png]]
![[Pasted image 20241226183320.png]]
第几组是由较低位地址决定的（offset之前的低位地址）
![[Pasted image 20241226183330.png]]
![[Pasted image 20241226183437.png]]

相联度越高 路数就越多 组数就越少，全相联只有一组，很多路
## 主存地址Tag、Index、块内偏移三个字段的计算

![[Pasted image 20241226183718.png]]
![[Pasted image 20241226183726.png]]
![[Pasted image 20241226183745.png]]
![[Pasted image 20241226183801.png]]
索引是用来找在哪一组的，cache的组越多，index位就越多，全相联只有一个组，所以不用index，除了block offset都是tag

## Cache块的替换策略

![[Pasted image 20241226183934.png]]
FIFO的替换看cache中谁先进来的
![[Pasted image 20241226183941.png]]
LRU看访问顺序中谁最早被访问
![[Pasted image 20241226183949.png]]


## Cache的读写过程
![[Pasted image 20241226184109.png]]
![[Pasted image 20241226184116.png]]
![[Pasted image 20241226184454.png]]
![[Pasted image 20241226184514.png]]
![[Pasted image 20241226184623.png]]
因为写到buffer里面的速度更快

![[Pasted image 20241226184642.png]]
![[Pasted image 20241226185053.png]]
![[Pasted image 20241226185114.png]]


## 平均访存时间和CPU时间的计算

![[Pasted image 20241226185139.png]]
![[Pasted image 20241226185149.png]]
![[Pasted image 20241226185312.png]]
![[Pasted image 20241226185352.png]]


## Cache失效率的类别，以及每种失效率的解决方法有哪些

强制失效 容量失效 冲突失效
![[Pasted image 20241226185854.png]]
相联度高，路数变多，冲突减少，但是因为要硬件同时比较更多的tag有可能使时钟周期变长
![[Pasted image 20241226185932.png]]
![[Pasted image 20241226190039.png]]
强制失效跟程序的大小有关系，跟容量没关系。减少强制失效，可以增加快大小，每次装入更多的程序。
![[Pasted image 20241226190110.png]]

![[Pasted image 20241226190308.png]]

![[Pasted image 20241226190330.png]]
减少 强制失效 但是增大了 容量失效（cache不够大） 和 冲突失效
Cache容量越大，使失效率达到最低的块大小就越大

![[Pasted image 20241226190506.png]]
增加块大小的方法会在降低失效率的同时增加失效开销，而提高相联度则是以增加命中时间为代价。

![[Pasted image 20241226190609.png]]
增大cache容量减小了 容量失效 和 冲突失效

![[Pasted image 20241226190653.png]]
![[Pasted image 20241226190739.png]]
![[Pasted image 20241226190750.png]]
![[Pasted image 20241226190805.png]]

### 减小失效开销：
![[Pasted image 20241226190830.png]]
![[Pasted image 20241226190904.png]]
![[Pasted image 20241226190915.png]]
![[Pasted image 20241226190950.png]]
![[Pasted image 20241226191000.png]]
![[Pasted image 20241226191041.png]]
![[Pasted image 20241226191119.png]]
![[Pasted image 20241226191151.png]]
![[Pasted image 20241226191210.png]]

### 减小命中时间

![[Pasted image 20241226191251.png]]
![[Pasted image 20241226191301.png]]


## 虚拟地址到物理地址的转换过程，TLB表的原理和作用，与Cache的关系，访存时间的最好情况和最坏情况的判断

![[Pasted image 20241226191317.png]]
![[Pasted image 20241226191425.png]]
![[Pasted image 20241226191453.png]]
由于写磁盘太长，页表应采用写回机制

页表 直接相联  通过虚拟地址索引 然后
![[Pasted image 20241226191536.png]]
![[Pasted image 20241226191819.png]]
![[Pasted image 20241226191854.png]]
![[Pasted image 20241226191923.png]]
![[Pasted image 20241226191950.png]]
![[Pasted image 20241226192014.png]]
TLB是全相联  页表一般是直接相联
![[Pasted image 20241226192035.png]]
![[Pasted image 20241226192100.png]]
![[Pasted image 20241226192105.png]]
查TLB时虚拟地址是tag

![[Pasted image 20241226192400.png]]
![[Pasted image 20241226192406.png]]
