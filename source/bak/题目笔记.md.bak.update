---
title: "题目笔记"
date: 2025-12-12 13:50:46
updated: 2025-12-12 13:50:46
mathjax: true
tags: 
    - LeetCode
    - Job
categories: 实用技巧
comments: true
---
# LeetCode Hot 100


## 1. [两数之和](https://leetcode.cn/problems/two-sum/)1-251210

#哈希表

```python
class Solution:
	def twoSum(self, nums: List[int], target: int) -> List[int]:
		dic = {}
		for i in range(len(nums)):
			residual = target - nums[i]
		if nums[i] in dic.keys():
			return [i, dic[nums[i]]]
		if residual not in dic.keys():
			dic[residual] = i
```

对每个数 留下 索引（value） 以及 到 target 的差（index），之后遇到 target差 的数，直接读出索引就行

## 2. [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)49-251210

#哈希表 #排序

### 思路一：哈希

```python
class Solution:

	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		map = {}
		for item in strs:
			v = self.str2value(item)
			if v in map.keys():
				map[v].append(item)
			else:
				map[v] = [item]
		return list(map.values())
	
	def str2value(self, stR:str) -> int :
		res = 0
		for char in stR:
			index = ord(char)-ord('a')
			res += 10**(index)
		return res*len(stR)
```

第一次的思路就是 把一个 str 得到一个顺序无关的哈希值。但是复杂度好像有点高。

更好的实现方式：使用了 `from collections import defaultdict` #内置函数

使用  defaultdict 是内置 dict 的子类，核心特性是，当访问不存在的键时，会自动创建这个键并赋值为 **指定默认值** 而不是抛出 KeyError。例如：初始化 `mp=collections.defaultdict(list)` 如果访问了不存在的键就会默认为空list （传入int就是默认0）

还有一个 dict 的索引不能是 list dict set，可以是int float tuple str bool None frozenset ，list 可以转为tuple

```python
class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		dic = collections.defaultdict(list)
		for s in strs:
			count = [0] * 26
			for c in s:
				count[ord(c)-ord('a')]+=1
			# 这一步的时间复杂度是 O(k)+1 ,k=26 tuple生成这个hash值需要 list长度的时间
			dic[tuple(count)].append(s)
		return list(dic.values())
```

这个方法时间复杂度是 O(n(k+s)) s是字符集的大小 26，每个 str 要 k 来遍历字符， s来生成 hash表的键。

### 思路二-排序\* 最优

对每个str排序，然后将排序的这个 字符串 当做字典的索引（哈希值）时间复杂度是 O(nklogk)

#内置函数
sorted 函数 输入字符串 返回一个按照 unicode 编码的 char list
''.join(list(char)) 把charlist 拼成一个串 注意这个join是 字符串的子函数

```python
class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		dic = collections.defaultdict(list)
		for s in strs:
			index = ''.join(sorted(s))
			dic[index].append(s)
		return list(dic.values())
```

## 3. [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)128-251210

#并查集 #set

这个题要求了时间复杂度为O(n) 所以不考虑排序的方法，首先用 set 对 nums 去重，然后找到 所有序列开头的数字 并计算 这个序列的长度，**由于每个数仅进入一次内层循环**，所以时间复杂度符合要求。

```python
class Solution:
	def longestConsecutive(self, nums: List[int]) -> int:
		res = 0
		nums_set = set(nums)
		for i in nums_set:
			if i-1 in nums_set:
				continue
			# 否则说明这个数是 一个序列的开头
			l = 1
			p = i+1
			while p in nums_set:
				l+=1
				p+=1
			res = max(res,l)
		return res
```

下面这个节省20ms的时间
```python
class Solution:
	def longestConsecutive(self, nums: List[int]) -> int:
		res = 0
		nums_set = set(nums)
		for i in nums_set:
			if i-1 in nums_set:
				continue
			# 否则说明这个数是 一个序列的开头
			p = i+1
			while p in nums_set:
				p+=1
			res = max(res,p-i)
		return res
```

这个算法的关键是找到起点 避免对一个数的重复遍历
list 转 set 还有 判断 in set 的操作 时间复杂度是 O(1), 如果是用 list 的 in 时间复杂度是 O(n)

## 4. [移动零](https://leetcode.cn/problems/move-zeroes/)283-251210

#双指针 #快慢指针

### 思路一 遇到零放后面

list ： remove是移除 第一个 value，pop是删掉指定index的item
顺序遍历，把0移到最后

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		"""
		Do not return anything, modify nums in-place instead.
		"""
		i=0
		last = len(nums)
		while i < last :
			if nums[i] == 0 :
				nums.pop(i)
				nums.append(0)
				last-=1
				i-=1
			i+=1
```

### 思路二 栈 遇到非零压入栈

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		stack_size=0
		for num in nums:
			if num :
				nums[stack_size] = num
				stack_size+=1
		nums[stack_size:len(nums)] = [0]*(len(nums)-stack_size)
```

这个方法在最坏的情况下（全是0） 要遍历两次数组

### 思路三 双指针\* 最优

依次把非零元素移动到 数组靠左边的空位置上。参考快速排序的想法，快拍要确定一个待分割的元素x作为中间点，然后小于等于x放到左边，大于x放到右边。

一个指向第一个0 另一个遇到第一个非零就和第一个0换位置，然后指向第一个0的后移一位（仍然是第一个0） （这个理解好像不太好）

换一个想法，两个指针，慢的说明 其左边 全部都是 保留顺序的非零（也就是指向待处理序列的第一个，只有交换了也就是处理好了，才移动），快的去找下一个需要被处理的非零数字。这样保留了原本的顺序。

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		slow=fast=0
		while fast < len(nums):
			if nums[fast]:
				nums[slow],nums[fast]=nums[fast],nums[slow]
				slow+=1
			fast+=1
```

## 5. [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)11-251210

#双指针

首先对于壁 i<j 有:  $S=min(height[i],height[j])*(j-i)$  .
每次移动 width 一定会减少1，那么只有 min h 变大才会得到更多的水，所以每次需要让短的板子移动。
为什么双指针合理呢？我觉得有的算法的做法就是通过数学思路，舍弃掉 暴搜 的大部分区域，对于这个而言，爆搜的空间有 $len^2/2,i<j$ , 然后通过证明可以省掉很多搜索空间。

![](https://cdn.jsdelivr.net/gh/zip95297/zip95297.github.io@main/source/images/%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/Pasted%20image%2020251211160109.webp?raw=true)

得到代码如下：
```python
class Solution:
	def S(self,i,j,h):
		h = h[i] if h[i]<h[j] else h[j]
		return abs(i-j)*h
	  
	def maxArea(self, height: List[int]) -> int:
		ans=0
		i,j = 0,len(height)-1
		while i!=j :
			ans = max(self.S(i,j,height),ans)
			if height[i]<height[j] :
				i+=1
			else :
				j-=1
		return ans
```

另一种想法，移动一边一定导致宽度下降，那么如果min(h,h)没有变大，就不需要计算，直接跳过就可以，直到高的最小值变大：
```python
class Solution:
	def maxArea(self, height: List[int]) -> int:
		l, r = 0, len(height) - 1
		ans = 0
		while l < r:
		# w = r - l
		h = min(height[l], height[r])
		ans = max(ans, (r - l) * h)
		while height[l] <= h and l < r: l += 1
		while height[r] <= h and l < r: r -= 1
	return ans
```


通过节省搜索空间的想法，还可以进一步，通过记录高度的最大值，得到最大的S，然后直接return

```python
class Solution:
	def maxArea(self, height: List[int]) -> int:
		max_area = 0
		l, r = 0, len(height) - 1
		max_height = max(height)
		  
		while l < r:
			if max_height * (r - l) < max_area:
				return max_area
			cur_area = min(height[l], height[r]) * (r - l)
			if cur_area > max_area:
				max_area = cur_area
			if height[l] > height[r]:
				r -= 1
			else:
				l += 1
		return max_area
```

## 6. [三数之和](https://leetcode.cn/problems/3sum/)15-251211

#双指针

最简单的想法 对于每个数 当做一个两数之和来做，但是由于两数之和的解法复杂度是 $O(n)$，这种做法的复杂度是 $O(n^2)$.

还有一种是用双指针，来找和为 0 的 也是最优的。

```python
class Solution:
	def threeSum(self, nums: List[int]) -> List[List[int]]:
		nums.sort()
		ans = []
		n = len(nums)
		for i in range(n - 2):
			x = nums[i]
			if i > 0 and x == nums[i - 1]: # 跳过重复数字
				continue
			if x > 0 or nums[-1]<0 : # 优化一
				break
			if x + nums[-2] + nums[-1] < 0: # 优化二
				continue
			j = i + 1
			k = n - 1
			while j < k:
				s = x + nums[j] + nums[k]
				if s > 0:
					k -= 1
				elif s < 0:
					j += 1
				else: # 三数之和为 0
					ans.append([x, nums[j], nums[k]])
					j += 1
					while j < k and nums[j] == nums[j - 1]: # 跳过重复数字
						j += 1
					k -= 1
					while k > j and nums[k] == nums[k + 1]: # 跳过重复数字
						k -= 1
		return ans
```

这个方法和 第一个复杂度都是$O(n^2)$ 但是双指针要快一些啊，是因为 枚举 + 哈希表法虽是 O (n²)，但哈希表的额外开销、随机内存访问导致常数项远大于双指针；1. 双指针法的「$O(n^2)$」是**真 $O(n^2)$**（外层 n 次，内层 n 次），且常数项极小；

## 7. [接雨水](https://leetcode.cn/problems/trapping-rain-water/)42-251211

#单调栈 #动态规划 #双指针

### 思路一：单调栈\*

最开始的思路是 遍历所有h 而不是index 有一个问题就是，如果相等的话之后来了更高的没办法记录宽度，所以尝试用index做一下

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		stack = []
		ans = 0
		for i,h in enumerate(height) :
			while stack and h > height[stack[-1]] :
				top = stack.pop()
				if not stack :
					break
				# 这个是重点部分 好好想一下
				ans += (min(height[stack[-1]],h)-height[top])*(i-stack[-1]-1)
			stack.append(i)
		return ans
```
这个部分我觉得最难的是 每次加多少面积，由于单调栈有单调递减的特征，所以栈顶元素一定是最小的，计算的思路就是 记录 每次pop 添加的水 是一排 就是接雨水 水平线往上的？

### 思路二：动态规划

每个位置 i 能接的水的数量 = min( i 左边的最大高度, i 右边的最大高度) - h\[i\] ,所以暴力搜索就是：
```python
class Solution:
	def trap(self, height: List[int]) -> int:
		ans = 0
		l = len(height)
		dp = [0] * l
		# 暴力
		for i in range(1,l-1) :
			dp[i] = max(min(max(height[0:i]),max(height[i+1:])) - height[i],0)
		return sum(dp)
```

在内循环中，在数组中找max操作复杂度为 $O(n)$ , 所以这个暴力搜索的复杂度为 $O(n^2)$ ，通过 动态规划的思路 先用两个list： $O(n)$ 来记录  index i 左边的最大和右边的最大height是多少。

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		l = len(height)
		ans = [0] * l
		# 左侧最大值 不包括
		leftMax = [0] * l
		# 右侧最大值 不包括
		rightMax = [0] * l
		maxh = 0
		maxr = 0
		# 这里也可以用动态规划的状态转移方程 会更快
		for i in range(l) :
			leftMax[i] = maxh
			maxh = maxh if maxh > height[i] else height[i]
			rightMax[l-1-i] = maxr
			maxr = maxr if maxr > height[l-1-i] else height[l-1-i]
		for i in range(1,l-1) :
			# ans[i] = max(min(max(height[0:i]),max(height[i+1:])) - height[i],0)
			ans[i] = max(min(leftMax[i],rightMax[i]) - height[i],0)
		return sum(ans)
```

### 思路三：双指针

本质上和动态规划类似，只是用双指针的方法可以把空间复杂度减到O1，时间复杂度还是 $O(n)$

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		ans = 0
		left, right = 0, len(height) - 1
		leftMax = rightMax = 0
		while left < right:
			leftMax = max(leftMax, height[left])
			rightMax = max(rightMax, height[right])
			if height[left] < height[right]:
				ans += leftMax - height[left]
				left += 1
			else:
				ans += rightMax - height[right]
				right -= 1
		return ans
```

## 8.  [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)3-251212

#滑动窗口

这个比较简单，可以学习一下别人的代码思路。下面这个是我的。

```python
class Solution:
	def lengthOfLongestSubstring(self, s: str) -> int:
		ans,i,l = 0,0,len(s)
		window = collections.deque()
		count = collections.defaultdict(int)
		while i < l :
			while i < l and count[s[i]] == 0 :
				window.append(s[i])
				count[s[i]] += 1
				i += 1
				ans = max(len(window),ans)
			while i < l and count[s[i]]!=0 :
				f = window.popleft()
				count[f] -= 1
		return ans
```

用 set（字典本身就适合处理 是否重复这样的事情）
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 滑动窗口
        left = 0
        window = set()
        max_length = 0
        for right in range(len(s)):
            while s[right] in window:
                window.remove(s[left])
                left += 1
            window.add(s[right])
            if len(window) > max_length:
                max_length = len(window)
        return max_length
```

这个2ms 最快
```python
class Solution:
	def lengthOfLongestSubstring(self, s: str) -> int:
		n = len(s)
		if n <= 1:
			return n
		_dict = {}
		start = -1
		res = 0
		for i, c in enumerate( s ):
			if c in _dict and _dict[c] > start:
				start = _dict[c]
			res = max(res, i - start)
			_dict[c] = i
		return res
```

## 9. [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)438-251212

#滑动窗口 

自己写的解
```python
class Solution:
	def findAnagrams(self, s: str, p: str) -> List[int]:
		ans = []
		count = {}
		window = collections.deque()
		for c in p :
			count[c] = 0
		for c in p :
			count[c] -= 1
		count['other'] = 0
		start = 0
		for c in s :
			window.append(c)
			if c in count.keys() :
				count[c] += 1
				while count[c] > 0 :
					f = window.popleft()
					start += 1
					count[f] -= 1
			else :
				count['other'] += 1
			while count['other'] != 0 :
				f = window.popleft()
				start += 1
				if f in count.keys() :
					count[f] -= 1
				else :
					count['other'] -= 1
			if len(window) == len(p) :
				ans.append(start)
		return ans
```

## 10. [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)560-251212

#前缀和

维护一个前n项和 sumn 然后 如果遇到 现在的 sumn - k 存在（x个） 那么就 有x个子数组符合
```python 
class Solution:
	def subarraySum(self, nums: List[int], k: int) -> int:
		ans,sumn = 0, 0
		cnt = collections.defaultdict(int)
		for n in nums:
			cnt[sumn] += 1
			sumn += n
			ans += cnt[sumn - k ]
		return ans
```

直到思路之后写了一次也没写对，当成两数之和了，存了index 应该是维护一个sumn为一个数的序列个数，之后再做一次

## 11. [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)239-251215

#大根堆 / #单调队列 #优先队列

### 思路一：大根堆

对于最大值这种问题，可以 维护一个 优先队列（大根堆）来做，也就是放入新元素是按照 我们想要的顺序存好。这个思路很容易想到，要善用这个数据结构。暴力的方法是，每次加入新元素就用$O(k)$ 来找一下窗口中的最大值，但是每个元素在整个流程中几乎被遍历k次，可以节省时间的方法就是记录在窗口中的元素的大小信息。也就是排序，但是如果每次来新的都排序，时间反而大于$O(k)$，因此需要我们维护一个 大根堆来做。在python中 最小堆是 ：heapq.heapify(list) 可以将一个list转换成最**小**堆 这个只保证**堆顶是 最小的** 而不是有序的

```python
class Solution:
	def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
		maxheap = [(-nums[i],i) for i in range(0,k) ]
		# 这个python 标准库的最小堆
		heapq.heapify(maxheap)
		ans = [ -maxheap[0][0] ]
		for i in range(k,len(nums)) :
			heapq.heappush(maxheap,(-nums[i],i))
			while maxheap[0][1] < i-k+1 :
				heapq.heappop(maxheap)
			ans.append(-maxheap[0][0])
		return ans
```

### 思路二：单调队列（优先队列）\*

对于下标  $i<j<i+k$  且 $nums[i]<nums[j]$ 如果 nums\[i] 在窗口中，那么 nums\[j] 一定也在. 所以如果出现这样的递增子序列，就可以将 i 给删除掉。
因此我们可以维护一个没有被移除的队列，这个队列是单调递减的。有因为窗口滑动，左侧还需要弹出，所以用双端队列。

```python
class Solution:
	def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
		q = collections.deque()
		ans = []
		for i in range(0,len(nums)) :
			while q and nums[i] >= nums[q[-1]] :
				q.pop()
			q.append(i)
			while q[0] <= i-k :
				q.popleft()
			if i >= k-1 :
				ans.append(nums[q[0]])
		return ans
```

维护了这样的单调递减序列，保证 开头是最大的，而且开头还得在窗口中。

## 12. [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)76-251215

#滑动窗口 

```python
class Solution:
	def minWindow(self, s:str, t: str) -> str:
		# 维护一个缺少多少的表
		w = collections.deque()
		rq = {}
		ansl ,l = 9999999,0
		ans = ''
		for c in t :
			if c in rq.keys() :
				rq[c] += 1
			else :
				rq[c] = 1
		# 处理队列，保证 rq 都得是 0
		for c in s :
			w.append(c)
			l += 1
			if c in rq.keys() :
				rq[c] -= 1
			while w :
				if w[0] in rq.keys() :
					print(rq[w[0]])
				if w[0] in rq.keys() :
					if rq[w[0]] >= 0 :
						break
					else :
						rq[w[0]] += 1
				w.popleft()
				l -= 1
			jump = False
			for i in rq.values() :
				if i > 0 :
					jump = True
			if ansl > l and jump == False :
				ansl = l
				ans = ''.join(w)
		return ans
```

## 13. [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)53-251215

#动态规划 #分治法 #前缀和 做题目的时候不要被刷过的题目的思路限制住方向 也要做新的想法尝试

### 思路一：DP

以 index 为 **结尾** 的最大子序列和
```python
class Solution :
	def maxSubArray(self, nums: List[int]) -> int :
		# 以index 为结尾的最大值
		dp = [0] * len(nums)
		for i,n in enumerate(nums) :
			dp[i] = max(dp[i-1]+nums[i],nums[i])
		return max(dp)
```

### 思路二：分治法（还没学1216）

官方题解说这个类似于 「线段树求解最长公共上升子序列问题」的pushup操作



### 思路三： 前缀和

参考 5盛水最多的容器中的动态规划方法，记录一个index左边最大和右边最小
```python
# class Solution:
# def maxSubArray(self, nums: List[int]) -> int:
# # 一个index左边的最小值，一个index右边的最大值
# leftMin,rightMax = [10001]*(len(nums)+1),[-10001]*(len(nums)+1)
# sn = [0] * (len(nums)+1)
# for i in range(len(nums)) :
# sn[i+1] = nums[i]
# for i in range(1,len(sn)) :
# sn[i] += sn[i-1]
# leftMin[0] = sn[0]
# rightMax[-1] = sn[-1]
# for i in range(1,len(sn)) :
# leftMin[i] = min(leftMin[i-1],sn[i])
# rightMax[len(sn)-1-i] = max(rightMax[len(sn)-i],sn[len(sn)-1-i])
# ans = -99999999
# for i in range(len(sn)-1) :
# if ans < rightMax[i+1] - leftMin[i] :
# ans = rightMax[i+1] - leftMin[i]
# return ans
```

维护两个太慢了，因为这个主要的约束 是 最小值在最大值的右边，通过记录最小值，然后计算 s\[n] 和 min 的差 来更新 结果：

```python
class Solution :
	def maxSubArray(self, nums: List[int]) -> int :
		tsum, tmin, ans = 0, 0, -99999
		for n in nums :
			tsum += n
			ans = max(ans,tsum-tmin)
			tmin = min(tmin,tsum)
		return ans
```

## 14. [合并区间](https://leetcode.cn/problems/merge-intervals/)56-251216

#排序 #数组 #单调栈

这个重点在于 排序的时候使用 lambda 表达式 lambda是个函数，lambda x: y 意思是输入 x 输出 y ，排序时候用sort(key =)

```python
# 20ms
class Solution:
	def merge(self, intervals: List[List[int]]) -> List[List[int]]:
		intervals.sort(key=lambda x: x[0])
		i = 0
		while True :
			if i+1 >= len(intervals) :
				break
			if intervals[i][1] >= intervals[i+1][0] :
				new_iv = [intervals[i][0],max(intervals[i][1],intervals[i+1][1])]
				intervals.remove(intervals[i+1])
				intervals[i] = new_iv
			else : i += 1
		return intervals
```

现在这种 每次的 remove 很慢 总体 20ms左右，还有一种方法是 维护一个 单调的栈，可以合并就合并后压栈否则就直接压. 这样结果就会快一点

```python
# 5ms
class Solution:
	def push(self,res_inv,item) :
		if len(res_inv) == 0 :
			res_inv.append(item)
		top = res_inv[-1]
		if top[1] >= item[0] :
			res_inv.pop()
			item = [top[0],max(top[1],item[1])]
		res_inv.append(item)
		return res_inv
		  
	def merge(self, intervals: List[List[int]]) -> List[List[int]]:
		ans = []
		intervals.sort(key=lambda x:x[0])
		for iv in intervals :
			self.push(ans,iv)
		return ans
```

## 15. [轮转数组](https://leetcode.cn/problems/rotate-array/)189-251216

```python
class Solution:
	def rotate(self, nums: List[int], k: int) -> None:
		"""
		Do not return anything, modify nums in-place instead.
		"""
		k = k%len(nums)
		nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]
```
需要注意的两个是 k 可能超过 nums 的长度，需要通过%来计算 时间移动了多少步
然后 下一行中 如果 nums\[:] 写成 nums ，那么nums就不会被修改 这个是python的一个特性 写成nums就是修改的这个局部变量 而不是修改了这个引用。

这个时间复杂度是 $O(n)$

\*最快的办法是反转数组：

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        # [1,2,3,4,5,6,7]
        # 1. 反转数组 [7,6,5,4,3,2,1]
        # 2. 反转前k=3个元素 [5,6,7, 4,3,2,1]
        # 3. 反转剩余元素 [5,6,7, 1,2,3,4]
        n = len(nums)
        k = k % n
        nums.reverse()
        nums[:k] = nums[:k][::-1]
        nums[k:] = nums[k:][::-1]
```

## 16. [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)238-251216

#前后缀 

### 思路一：前后缀积

这个 也是用 前缀后缀积 但是不需要 维护两个list 因为我们知道最后的目的是 在 index位置 ans\[i] = $\prod_{j\ne i}nums_j$  所以不妨 先正向遍历拿到前面的积 再反向遍历，拿到后面的积。

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        length = len(nums)
        answer = [0] * length
        answer[0] = 1
        for i in range(1, length):
            answer[i] = nums[i - 1] * answer[i - 1]
        R = 1
        for i in reversed(range(length)):
            answer[i] = answer[i] * R 
            R *= nums[i]
        return answer
```

### UES

这个解法考虑了0 同时用了reduce函数可以看一下

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        if 0 in nums:
            ret= [0]*len(nums)
            if nums.count(0)>=2:
                return ret
            ret[nums.index(0)]=reduce(mul,(i for i in nums if i!=0),)
            return ret
        p=reduce(mul,nums,)
        if p!=0:
            return [p//i for i in nums]
```
### Trash

用 前缀积 后缀积 来在 $O(n)$ 时间复杂度解决这个问题 但是 空间复杂度是 $O(n)$

```python
class Solution:
	def productExceptSelf(self, nums: List[int]) -> List[int]:
		fD, bD = nums[:], nums[:] # 定义前缀后缀积
		for i in range(1,len(nums)) :
			fD[i] *= fD[i-1]
			bD[len(nums)-i-1] *= bD[len(nums)-i]
		ans = [ bD[1] ]
		for i in range(1,len(nums)-1) :
			ans.append( fD[i-1] * bD[i+1] )
		ans.append(fD[-2])
		return ans
```

## 17. [缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)41-251216


### 思路一：原地哈希(节省内存)

参考这个：[寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

ans 最大的情况 就是 1,len(nums)都在 ，那么如果把 nums 中的 值 作为 index 那么肯定有 index 用不完的情况，第一个没用的就是 答案。
v\[index] 是负数，那么这个index 可以直接拿来用，如果 v\[i]>0 那么我们就需要把 这个 v\[i] 也给记录下来。向链表一样顺着找

```python
class Solution:
	def firstMissingPositive(self, nums: List[int]) -> int:
		l = len(nums)
		for i in range(len(nums)) :
			target = nums[i]-1
			if target < 0 or target >= l :
				continue
			while nums[target] <= l and nums[target] > 0 :
				if nums[target] == target + 1 :
					break
				next_target = nums[target] - 1
				nums[target] = target + 1
				target = next_target
			nums[target] = target + 1
		for i in range(len(nums)) :
			if i+1 != nums[i] :
				return i+1
		else :
			return l+1
```


题解中的原地哈希，这个比上面的方法更好 
```python
class Solution:
	def firstMissingPositive(self, nums: List[int]) -> int:
		n = len(nums)
		for i in range(n):
			if nums[i] <= 0:
			nums[i] = n + 1
		for i in range(n):
			num = abs(nums[i])
			if num <= n:
				nums[num - 1] = -abs(nums[num - 1])
		for i in range(n):
			if nums[i] > 0:
				return i + 1
		return n + 1
```
### Trash
题目中限制了空间复杂度是常数，如果不考虑空间，这个方法很快
```python
class Solution:
	def firstMissingPositive(self, nums: List[int]) -> int:
		ans = len(nums)+1
		s = set(nums)
		for i in range(len(nums),0,-1) :
			if i in s :
				continue
			else : ans = min(ans,i)
		return ans
```

## 18. [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)73-251216

先处理行再处理列 这个是 $O(mn)$ 时间复杂度。空间复杂度是 $O(n)$  

```python
class Solution:
	def setZeroes(self, matrix: List[List[int]]) -> None:
		"""
		Do not return anything, modify matrix in-place instead.
		"""
		c_index = set()
		for i,n in enumerate(matrix) :
			if 0 in n :
				index = [ -1 if n[index]!=0 else index for index in range(len(n)) ]
				[c_index.add(x) for x in index]
				matrix[i] = [0] * len(n)
		for i,n in enumerate(matrix) :
			for j in range(len(n)) :
				if j in c_index:
					matrix[i][j] = 0
```

## 19. [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)54-251216

遇到墙换方向

```python
class Solution:
	def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
		ans = []
		i,j = 0,0
		down = len(matrix)
		right = len(matrix[0])
		total = down * right
		left = 1
		up = 1
		  
		di,dj = 0,1
		cnt = 0
		if right == 1 :
			ans = [ i[0] for i in matrix ]
			return ans
		  
		while True :
			print(i,j)
			ans.append(matrix[i][j])
			cnt += 1
			if cnt == total :
				break
				i,j = i+di,j+dj
			if j == right-1 and di == 0 and dj == 1 :
				di,dj = 1,0
				up = up + 1
			if i == down-1 and di == 1 and dj == 0 :
				di,dj = 0,-1
				right = right - 1
			if j == left - 1 and di == 0 and dj == -1 :
				di,dj = -1,0
				down = down - 1
			if i == up - 1 and di == -1 and dj == 0 :
				di,dj = 0,1
				left = left + 1
		return ans
```


## 20. [旋转图像](https://leetcode.cn/problems/rotate-image/)48-251216

主要是下标处理 这几个矩阵相关的题目

```python
class Solution:
	def p_single_pos(self,nums,i,j):
		self.swap(nums,i,j,j,self.col-i-1)
		self.swap(nums,i,j,self.row-i-1,self.col-j-1)
		self.swap(nums,i,j,self.row-j-1,i)
		  
	def swap(self,nums,i,j,k,l):
		temp = nums[i][j]
		nums[i][j] = nums[k][l]
		nums[k][l] = temp
		  
	def rotate(self, matrix: List[List[int]]) -> None:
		"""
		Do not return anything, modify matrix in-place instead.
		"""
		self.row = len(matrix)
		self.col = len(matrix[0])
		for i in range(self.col//2 + 1) :
			pos_list = [ [i,x] for x in range(i,self.col-i-1) ]
			for t in pos_list :
				self.p_single_pos(matrix,t[0],t[1])
```

## 21. [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)240-251216

#二分查找 #分治法 

### 思路一：Z字形查找

最简单的想法，时间复杂度是 $O(n+m)$ 

```python
class Solution:
	def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
		maxColIndex = len(matrix[0])-1
		for i,n in enumerate(matrix[0]) :
			if n >= target :
				maxColIndex = i-1
			if n == target :
				return True
		print(maxColIndex)
		for i in range(0,maxColIndex+1):
			for j in range(len(matrix)) :
				if matrix[j][i] == target :
					return True
				if matrix[j][i] > target :
					break
		return False
```

### 思路二：二分查找

```python
class Solution:
	def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
		for row in matrix:
			if row[0] > target :
				break
			idx = bisect.bisect_left(row, target)
			if idx < len(row) and row[idx] == target:
				return True
		return False
```

防止不会 自己写一下 binary search
```python
class Solution:
	def bs(self,nums,target):
		mid = (len(nums))//2
		print(mid,nums)
		if nums[0] > target :
			return None
		if nums[-1] < target :
			return None
		if nums[mid] > target :
			return self.bs(nums[0:mid],target)
		elif nums[mid] < target :
			return self.bs(nums[mid+1:],target)
		else : return mid
	
	def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
		for row in matrix:
			if row[0] > target :
				break
			idx = self.bs(row, target)
			if idx!=None :
				return True
		return False
```

### 思路三：贪心Z*  从左下角开始搜索！

操了 这个和前面的 Z搜索区别在于 从左下角开始搜索，这样的话就可以沿着 减增减 的序列搜索了 可以排除更多不可能区域. 我觉得这个想法**非常好**。
[参考题解](https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/2361487/240-sou-suo-er-wei-ju-zhen-iitan-xin-qin-7mtf)

```python
class Solution:
	def searchMatrix(self, matrix, target) -> bool :
		i, j = len(matrix)-1,0
		while i>=0 and j<=len(matrix[0])-1 :
			if matrix[i][j] == target :
				return True
			i,j = (i-1,j) if matrix[i][j] > target else (i,j+1)
			# if matrix[i][j] > target :
			# 	i -= 1
			# else :
			#  	j += 1
		return False
```

## 22. [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)160-251217


