---
title: "题目笔记"
date: 2025-12-12 13:50:46
updated: 2025-12-12 13:50:46
mathjax: true
tags: 
    - LeetCode
    - Job
categories: 实用技巧
comments: true
---
# LeetCode Hot 100


## 1. [两数之和](https://leetcode.cn/problems/two-sum/)1-251210

#哈希表

```python
class Solution:
	def twoSum(self, nums: List[int], target: int) -> List[int]:
		dic = {}
		for i in range(len(nums)):
			residual = target - nums[i]
		if nums[i] in dic.keys():
			return [i, dic[nums[i]]]
		if residual not in dic.keys():
			dic[residual] = i
```

对每个数 留下 索引（value） 以及 到 target 的差（index），之后遇到 target差 的数，直接读出索引就行

## 2. [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)49-251210

#哈希表 #排序

### 思路一：哈希

```python
class Solution:

	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		map = {}
		for item in strs:
			v = self.str2value(item)
			if v in map.keys():
				map[v].append(item)
			else:
				map[v] = [item]
		return list(map.values())
	
	def str2value(self, stR:str) -> int :
		res = 0
		for char in stR:
			index = ord(char)-ord('a')
			res += 10**(index)
		return res*len(stR)
```

第一次的思路就是 把一个 str 得到一个顺序无关的哈希值。但是复杂度好像有点高。

更好的实现方式：使用了 `from collections import defaultdict` #内置函数

使用  defaultdict 是内置 dict 的子类，核心特性是，当访问不存在的键时，会自动创建这个键并赋值为 **指定默认值** 而不是抛出 KeyError。例如：初始化 `mp=collections.defaultdict(list)` 如果访问了不存在的键就会默认为空list （传入int就是默认0）

还有一个 dict 的索引不能是 list dict set，可以是int float tuple str bool None frozenset ，list 可以转为tuple

```python
class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		dic = collections.defaultdict(list)
		for s in strs:
			count = [0] * 26
			for c in s:
				count[ord(c)-ord('a')]+=1
			# 这一步的时间复杂度是 O(k)+1 ,k=26 tuple生成这个hash值需要 list长度的时间
			dic[tuple(count)].append(s)
		return list(dic.values())
```

这个方法时间复杂度是 O(n(k+s)) s是字符集的大小 26，每个 str 要 k 来遍历字符， s来生成 hash表的键。

### 思路二-排序\* 最优

对每个str排序，然后将排序的这个 字符串 当做字典的索引（哈希值）时间复杂度是 O(nklogk)

#内置函数
sorted 函数 输入字符串 返回一个按照 unicode 编码的 char list
''.join(list(char)) 把charlist 拼成一个串 注意这个join是 字符串的子函数

```python
class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
		dic = collections.defaultdict(list)
		for s in strs:
			index = ''.join(sorted(s))
			dic[index].append(s)
		return list(dic.values())
```

## 3. [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)128-251210

#并查集 #set

这个题要求了时间复杂度为O(n) 所以不考虑排序的方法，首先用 set 对 nums 去重，然后找到 所有序列开头的数字 并计算 这个序列的长度，**由于每个数仅进入一次内层循环**，所以时间复杂度符合要求。

```python
class Solution:
	def longestConsecutive(self, nums: List[int]) -> int:
		res = 0
		nums_set = set(nums)
		for i in nums_set:
			if i-1 in nums_set:
				continue
			# 否则说明这个数是 一个序列的开头
			l = 1
			p = i+1
			while p in nums_set:
				l+=1
				p+=1
			res = max(res,l)
		return res
```

下面这个节省20ms的时间
```python
class Solution:
	def longestConsecutive(self, nums: List[int]) -> int:
		res = 0
		nums_set = set(nums)
		for i in nums_set:
			if i-1 in nums_set:
				continue
			# 否则说明这个数是 一个序列的开头
			p = i+1
			while p in nums_set:
				p+=1
			res = max(res,p-i)
		return res
```

这个算法的关键是找到起点 避免对一个数的重复遍历
list 转 set 还有 判断 in set 的操作 时间复杂度是 O(1), 如果是用 list 的 in 时间复杂度是 O(n)

## 4. [移动零](https://leetcode.cn/problems/move-zeroes/)283-251210

#双指针 #快慢指针

### 思路一 遇到零放后面

list ： remove是移除 第一个 value，pop是删掉指定index的item
顺序遍历，把0移到最后

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		"""
		Do not return anything, modify nums in-place instead.
		"""
		i=0
		last = len(nums)
		while i < last :
			if nums[i] == 0 :
				nums.pop(i)
				nums.append(0)
				last-=1
				i-=1
			i+=1
```

### 思路二 栈 遇到非零压入栈

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		stack_size=0
		for num in nums:
			if num :
				nums[stack_size] = num
				stack_size+=1
		nums[stack_size:len(nums)] = [0]*(len(nums)-stack_size)
```

这个方法在最坏的情况下（全是0） 要遍历两次数组

### 思路三 双指针\* 最优

依次把非零元素移动到 数组靠左边的空位置上。参考快速排序的想法，快拍要确定一个待分割的元素x作为中间点，然后小于等于x放到左边，大于x放到右边。

一个指向第一个0 另一个遇到第一个非零就和第一个0换位置，然后指向第一个0的后移一位（仍然是第一个0） （这个理解好像不太好）

换一个想法，两个指针，慢的说明 其左边 全部都是 保留顺序的非零（也就是指向待处理序列的第一个，只有交换了也就是处理好了，才移动），快的去找下一个需要被处理的非零数字。这样保留了原本的顺序。

```python
class Solution:
	def moveZeroes(self, nums: List[int]) -> None:
		slow=fast=0
		while fast < len(nums):
			if nums[fast]:
				nums[slow],nums[fast]=nums[fast],nums[slow]
				slow+=1
			fast+=1
```

## 5. [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)11-251210

#双指针

首先对于壁 i<j 有:  $S=min(height[i],height[j])*(j-i)$  .
每次移动 width 一定会减少1，那么只有 min h 变大才会得到更多的水，所以每次需要让短的板子移动。
为什么双指针合理呢？我觉得有的算法的做法就是通过数学思路，舍弃掉 暴搜 的大部分区域，对于这个而言，爆搜的空间有 $len^2/2,i<j$ , 然后通过证明可以省掉很多搜索空间。

![](https://cdn.jsdelivr.net/gh/zip95297/zip95297.github.io@main/source/images/%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/Pasted%20image%2020251211160109.webp?raw=true)

得到代码如下：
```python
class Solution:
	def S(self,i,j,h):
		h = h[i] if h[i]<h[j] else h[j]
		return abs(i-j)*h
	  
	def maxArea(self, height: List[int]) -> int:
		ans=0
		i,j = 0,len(height)-1
		while i!=j :
			ans = max(self.S(i,j,height),ans)
			if height[i]<height[j] :
				i+=1
			else :
				j-=1
		return ans
```

另一种想法，移动一边一定导致宽度下降，那么如果min(h,h)没有变大，就不需要计算，直接跳过就可以，直到高的最小值变大：
```python
class Solution:
	def maxArea(self, height: List[int]) -> int:
		l, r = 0, len(height) - 1
		ans = 0
		while l < r:
		# w = r - l
		h = min(height[l], height[r])
		ans = max(ans, (r - l) * h)
		while height[l] <= h and l < r: l += 1
		while height[r] <= h and l < r: r -= 1
	return ans
```


通过节省搜索空间的想法，还可以进一步，通过记录高度的最大值，得到最大的S，然后直接return

```python
class Solution:
	def maxArea(self, height: List[int]) -> int:
		max_area = 0
		l, r = 0, len(height) - 1
		max_height = max(height)
		  
		while l < r:
			if max_height * (r - l) < max_area:
				return max_area
			cur_area = min(height[l], height[r]) * (r - l)
			if cur_area > max_area:
				max_area = cur_area
			if height[l] > height[r]:
				r -= 1
			else:
				l += 1
		return max_area
```

## 6. [三数之和](https://leetcode.cn/problems/3sum/)15-251211

#双指针

最简单的想法 对于每个数 当做一个两数之和来做，但是由于两数之和的解法复杂度是 $O(n)$，这种做法的复杂度是 $O(n^2)$.

还有一种是用双指针，来找和为 0 的 也是最优的。

```python
class Solution:
	def threeSum(self, nums: List[int]) -> List[List[int]]:
		nums.sort()
		ans = []
		n = len(nums)
		for i in range(n - 2):
			x = nums[i]
			if i > 0 and x == nums[i - 1]: # 跳过重复数字
				continue
			if x > 0 or nums[-1]<0 : # 优化一
				break
			if x + nums[-2] + nums[-1] < 0: # 优化二
				continue
			j = i + 1
			k = n - 1
			while j < k:
				s = x + nums[j] + nums[k]
				if s > 0:
					k -= 1
				elif s < 0:
					j += 1
				else: # 三数之和为 0
					ans.append([x, nums[j], nums[k]])
					j += 1
					while j < k and nums[j] == nums[j - 1]: # 跳过重复数字
						j += 1
					k -= 1
					while k > j and nums[k] == nums[k + 1]: # 跳过重复数字
						k -= 1
		return ans
```

这个方法和 第一个复杂度都是$O(n^2)$ 但是双指针要快一些啊，是因为 枚举 + 哈希表法虽是 O (n²)，但哈希表的额外开销、随机内存访问导致常数项远大于双指针；1. 双指针法的「$O(n^2)$」是**真 $O(n^2)$**（外层 n 次，内层 n 次），且常数项极小；

## 7. [接雨水](https://leetcode.cn/problems/trapping-rain-water/)42-251211

#单调栈 #动态规划 #双指针

### 思路一：单调栈\*

最开始的思路是 遍历所有h 而不是index 有一个问题就是，如果相等的话之后来了更高的没办法记录宽度，所以尝试用index做一下

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		stack = []
		ans = 0
		for i,h in enumerate(height) :
			while stack and h > height[stack[-1]] :
				top = stack.pop()
				if not stack :
					break
				# 这个是重点部分 好好想一下
				ans += (min(height[stack[-1]],h)-height[top])*(i-stack[-1]-1)
			stack.append(i)
		return ans
```
这个部分我觉得最难的是 每次加多少面积，由于单调栈有单调递减的特征，所以栈顶元素一定是最小的，计算的思路就是 记录 每次pop 添加的水 是一排 就是接雨水 水平线往上的？

### 思路二：动态规划

每个位置 i 能接的水的数量 = min( i 左边的最大高度, i 右边的最大高度) - h\[i\] ,所以暴力搜索就是：
```python
class Solution:
	def trap(self, height: List[int]) -> int:
		ans = 0
		l = len(height)
		dp = [0] * l
		# 暴力
		for i in range(1,l-1) :
			dp[i] = max(min(max(height[0:i]),max(height[i+1:])) - height[i],0)
		return sum(dp)
```

在内循环中，在数组中找max操作复杂度为 $O(n)$ , 所以这个暴力搜索的复杂度为 $O(n^2)$ ，通过 动态规划的思路 先用两个list： $O(n)$ 来记录  index i 左边的最大和右边的最大height是多少。

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		l = len(height)
		ans = [0] * l
		# 左侧最大值 不包括
		leftMax = [0] * l
		# 右侧最大值 不包括
		rightMax = [0] * l
		maxh = 0
		maxr = 0
		# 这里也可以用动态规划的状态转移方程 会更快
		for i in range(l) :
			leftMax[i] = maxh
			maxh = maxh if maxh > height[i] else height[i]
			rightMax[l-1-i] = maxr
			maxr = maxr if maxr > height[l-1-i] else height[l-1-i]
		for i in range(1,l-1) :
			# ans[i] = max(min(max(height[0:i]),max(height[i+1:])) - height[i],0)
			ans[i] = max(min(leftMax[i],rightMax[i]) - height[i],0)
		return sum(ans)
```

### 思路三：双指针

本质上和动态规划类似，只是用双指针的方法可以把空间复杂度减到O1，时间复杂度还是 $O(n)$

```python
class Solution:
	def trap(self, height: List[int]) -> int:
		ans = 0
		left, right = 0, len(height) - 1
		leftMax = rightMax = 0
		while left < right:
			leftMax = max(leftMax, height[left])
			rightMax = max(rightMax, height[right])
			if height[left] < height[right]:
				ans += leftMax - height[left]
				left += 1
			else:
				ans += rightMax - height[right]
				right -= 1
		return ans
```

## 8.  [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)3-251212

#滑动窗口

这个比较简单，可以学习一下别人的代码思路。下面这个是我的。

```python
class Solution:
	def lengthOfLongestSubstring(self, s: str) -> int:
		ans,i,l = 0,0,len(s)
		window = collections.deque()
		count = collections.defaultdict(int)
		while i < l :
			while i < l and count[s[i]] == 0 :
				window.append(s[i])
				count[s[i]] += 1
				i += 1
				ans = max(len(window),ans)
			while i < l and count[s[i]]!=0 :
				f = window.popleft()
				count[f] -= 1
		return ans
```

用 set（字典本身就适合处理 是否重复这样的事情）
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # 滑动窗口
        left = 0
        window = set()
        max_length = 0
        for right in range(len(s)):
            while s[right] in window:
                window.remove(s[left])
                left += 1
            window.add(s[right])
            if len(window) > max_length:
                max_length = len(window)
        return max_length
```

这个2ms 最快
```python
class Solution:
	def lengthOfLongestSubstring(self, s: str) -> int:
		n = len(s)
		if n <= 1:
			return n
		_dict = {}
		start = -1
		res = 0
		for i, c in enumerate( s ):
			if c in _dict and _dict[c] > start:
				start = _dict[c]
			res = max(res, i - start)
			_dict[c] = i
		return res
```

## 9. [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)438-251212

#滑动窗口 

自己写的解
```python
class Solution:
	def findAnagrams(self, s: str, p: str) -> List[int]:
		ans = []
		count = {}
		window = collections.deque()
		for c in p :
			count[c] = 0
		for c in p :
			count[c] -= 1
		count['other'] = 0
		start = 0
		for c in s :
			window.append(c)
			if c in count.keys() :
				count[c] += 1
				while count[c] > 0 :
					f = window.popleft()
					start += 1
					count[f] -= 1
			else :
				count['other'] += 1
			while count['other'] != 0 :
				f = window.popleft()
				start += 1
				if f in count.keys() :
					count[f] -= 1
				else :
					count['other'] -= 1
			if len(window) == len(p) :
				ans.append(start)
		return ans
```

## 10. [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)560-251212

#前缀和

维护一个前n项和 sumn 然后 如果遇到 现在的 sumn - k 存在（x个） 那么就 有x个子数组符合
```python 
class Solution:
	def subarraySum(self, nums: List[int], k: int) -> int:
		ans,sumn = 0, 0
		cnt = collections.defaultdict(int)
		for n in nums:
			cnt[sumn] += 1
			sumn += n
			ans += cnt[sumn - k ]
		return ans
```

直到思路之后写了一次也没写对，当成两数之和了，存了index 应该是维护一个sumn为一个数的序列个数，之后再做一次

## 11. [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)239-251215

#大根堆 / #单调队列 #优先队列

### 思路一：大根堆

对于最大值这种问题，可以 维护一个 优先队列（大根堆）来做，也就是放入新元素是按照 我们想要的顺序存好。这个思路很容易想到，要善用这个数据结构。暴力的方法是，每次加入新元素就用$O(k)$ 来找一下窗口中的最大值，但是每个元素在整个流程中几乎被遍历k次，可以节省时间的方法就是记录在窗口中的元素的大小信息。也就是排序，但是如果每次来新的都排序，时间反而大于$O(k)$，因此需要我们维护一个 大根堆来做。在python中 最小堆是 ：heapq.heapify(list) 可以将一个list转换成最**小**堆 这个只保证**堆顶是 最小的** 而不是有序的

```python
class Solution:
	def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
		maxheap = [(-nums[i],i) for i in range(0,k) ]
		# 这个python 标准库的最小堆
		heapq.heapify(maxheap)
		ans = [ -maxheap[0][0] ]
		for i in range(k,len(nums)) :
			heapq.heappush(maxheap,(-nums[i],i))
			while maxheap[0][1] < i-k+1 :
				heapq.heappop(maxheap)
			ans.append(-maxheap[0][0])
		return ans
```

### 思路二：单调队列（优先队列）\*

对于下标  $i<j<i+k$  且 $nums[i]<nums[j]$ 如果 nums\[i] 在窗口中，那么 nums\[j] 一定也在. 所以如果出现这样的递增子序列，就可以将 i 给删除掉。
因此我们可以维护一个没有被移除的队列，这个队列是单调递减的。有因为窗口滑动，左侧还需要弹出，所以用双端队列。

```python
class Solution:
	def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
		q = collections.deque()
		ans = []
		for i in range(0,len(nums)) :
			while q and nums[i] >= nums[q[-1]] :
				q.pop()
			q.append(i)
			while q[0] <= i-k :
				q.popleft()
			if i >= k-1 :
				ans.append(nums[q[0]])
		return ans
```

维护了这样的单调递减序列，保证 开头是最大的，而且开头还得在窗口中。

## 12. [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)76-251215

#滑动窗口 

```python
class Solution:
	def minWindow(self, s:str, t: str) -> str:
		# 维护一个缺少多少的表
		w = collections.deque()
		rq = {}
		ansl ,l = 9999999,0
		ans = ''
		for c in t :
			if c in rq.keys() :
				rq[c] += 1
			else :
				rq[c] = 1
		# 处理队列，保证 rq 都得是 0
		for c in s :
			w.append(c)
			l += 1
			if c in rq.keys() :
				rq[c] -= 1
			while w :
				if w[0] in rq.keys() :
					print(rq[w[0]])
				if w[0] in rq.keys() :
					if rq[w[0]] >= 0 :
						break
					else :
						rq[w[0]] += 1
				w.popleft()
				l -= 1
			jump = False
			for i in rq.values() :
				if i > 0 :
					jump = True
			if ansl > l and jump == False :
				ansl = l
				ans = ''.join(w)
		return ans
```

## 13. [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)53-251215

#动态规划 #分治法 #前缀和 做题目的时候不要被刷过的题目的思路限制住方向 也要做新的想法尝试

### 思路一：DP

以 index 为 **结尾** 的最大子序列和
```python
class Solution :
	def maxSubArray(self, nums: List[int]) -> int :
		# 以index 为结尾的最大值
		dp = [0] * len(nums)
		for i,n in enumerate(nums) :
			dp[i] = max(dp[i-1]+nums[i],nums[i])
		return max(dp)
```

### 思路二：分治法（还没学1216）

官方题解说这个类似于 「线段树求解最长公共上升子序列问题」的pushup操作



### 思路三： 前缀和

参考 5盛水最多的容器中的动态规划方法，记录一个index左边最大和右边最小
```python
# class Solution:
# def maxSubArray(self, nums: List[int]) -> int:
# # 一个index左边的最小值，一个index右边的最大值
# leftMin,rightMax = [10001]*(len(nums)+1),[-10001]*(len(nums)+1)
# sn = [0] * (len(nums)+1)
# for i in range(len(nums)) :
# sn[i+1] = nums[i]
# for i in range(1,len(sn)) :
# sn[i] += sn[i-1]
# leftMin[0] = sn[0]
# rightMax[-1] = sn[-1]
# for i in range(1,len(sn)) :
# leftMin[i] = min(leftMin[i-1],sn[i])
# rightMax[len(sn)-1-i] = max(rightMax[len(sn)-i],sn[len(sn)-1-i])
# ans = -99999999
# for i in range(len(sn)-1) :
# if ans < rightMax[i+1] - leftMin[i] :
# ans = rightMax[i+1] - leftMin[i]
# return ans
```

维护两个太慢了，因为这个主要的约束 是 最小值在最大值的右边，通过记录最小值，然后计算 s\[n] 和 min 的差 来更新 结果：

```python
class Solution :
	def maxSubArray(self, nums: List[int]) -> int :
		tsum, tmin, ans = 0, 0, -99999
		for n in nums :
			tsum += n
			ans = max(ans,tsum-tmin)
			tmin = min(tmin,tsum)
		return ans
```

## 14. [合并区间](https://leetcode.cn/problems/merge-intervals/)56-251215

#排序 #数组 #单调栈

这个重点在于 排序的时候使用 lambda 表达式 lambda是个函数，lambda x: y 意思是输入 x 输出 y ，排序时候用sort(key =)

```python
# 20ms
class Solution:
	def merge(self, intervals: List[List[int]]) -> List[List[int]]:
		intervals.sort(key=lambda x: x[0])
		i = 0
		while True :
			if i+1 >= len(intervals) :
				break
			if intervals[i][1] >= intervals[i+1][0] :
				new_iv = [intervals[i][0],max(intervals[i][1],intervals[i+1][1])]
				intervals.remove(intervals[i+1])
				intervals[i] = new_iv
			else : i += 1
		return intervals
```

现在这种 每次的 remove 很慢 总体 20ms左右，还有一种方法是 维护一个 单调的栈，可以合并就合并后压栈否则就直接压. 这样结果就会快一点

```python
# 5ms
class Solution:
	def push(self,res_inv,item) :
		if len(res_inv) == 0 :
			res_inv.append(item)
		top = res_inv[-1]
		if top[1] >= item[0] :
			res_inv.pop()
			item = [top[0],max(top[1],item[1])]
		res_inv.append(item)
		return res_inv
		  
	def merge(self, intervals: List[List[int]]) -> List[List[int]]:
		ans = []
		intervals.sort(key=lambda x:x[0])
		for iv in intervals :
			self.push(ans,iv)
		return ans
```

## 15. [轮转数组](https://leetcode.cn/problems/rotate-array/)189-251215

```python
class Solution:
	def rotate(self, nums: List[int], k: int) -> None:
		"""
		Do not return anything, modify nums in-place instead.
		"""
		k = k%len(nums)
		nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]
```
需要注意的两个是 k 可能超过 nums 的长度，需要通过%来计算 时间移动了多少步
然后 下一行中 如果 nums\[:] 写成 nums ，那么nums就不会被修改 这个是python的一个特性 写成nums就是修改的这个局部变量 而不是修改了这个引用。

这个时间复杂度是 $O(n)$

\*最快的办法是反转数组：

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        # [1,2,3,4,5,6,7]
        # 1. 反转数组 [7,6,5,4,3,2,1]
        # 2. 反转前k=3个元素 [5,6,7, 4,3,2,1]
        # 3. 反转剩余元素 [5,6,7, 1,2,3,4]
        n = len(nums)
        k = k % n
        nums.reverse()
        nums[:k] = nums[:k][::-1]
        nums[k:] = nums[k:][::-1]
```

## 16. [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)238-251215




